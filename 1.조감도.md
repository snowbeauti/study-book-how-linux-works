# 조감도

추상(abstraction)
> 운영체제가 동작하는 방법을 이해하는 가장 효과적인 방법   
> 상세한 부분을 대부분 무시하는 것을 표현한 말
> <pre><code> ex) 차를 타고 있는 상태로 차를 타는 방법, 차의 행위(운반) 정도만 알면 됨   
> 운전하고 있는 상태로 승차감이 좋지 않을 때에는    
> "도로를 운행하는 차"에 대해 추상 기법을 통해 차, 길, 운행방법으로 분리해 볼 수 있음   
> 만약 길이 울퉁불퉁 하다면, 운행방법의 문제로 볼 수 없으며    
> 도로사정이 악화된 이유, 새 도로라면 작업부실 이유 등을 알아야 함
></pre></code>
>   
> 운영체제와 그 응용프로그램을 구축할 때 추상을 하나의 툴로 활용함   
> **서브시스템(suvsystem)**, **모듈(module)**, **패키지(package)**, **컴포넌트(component)** 등 추상화된 부분에 대한 용어들이 존재함
<br>
<br>
<hr/>   

1.1 리눅스 시스템의 추상화 레벨과 레이어 <br>
> **레이어(layer)** , **레벨(level)** 은 사용자와 하드웨어 사이 해당 구성요소가 어디에 위치하는지에 따라 구분한다. <br>  
> <pre><code> ex) 최상위 레이어 : 웹브라우저, 게임 등   
> 중간 레이어들 : 운영체제   
> 최하위 레이어 : 컴퓨터 하드웨어의 메모리, 0,1 등 
></pre></code>
>   
> 운영체제와 그 응용프로그램을 구축할 때 추상을 하나의 툴로 활용함   
> **서브시스템(suvsystem)**, **모듈(module)**, **패키지(package)**, **컴포넌트(component)** 등 추상화된 부분에 대한 용어들이 존재함
> <br>
> <br>
> **1.하드웨어**
> >기저부에 위치<br>
> >계산을 처리하고, 메모리를 읽거나 기록하는 하나 이상의 중앙처리장치와 메모리를 포함하는 것<br>
> >ex)디스크와 네트워크 인터페이스 같은 장치<br>
>    
> **2.커널** <br>
> > 중간레벨<br>
> > 운영체제의 핵심<br>
> > 메모리안에 존재하는 소프트웨어로, CPU가 해야할일을 전달<br>
> > 하드웨어를 관리하고 주로 하드웨어와 실행중인 프로그램 사이의 인터페이스로써 동작<br>
> > 커널모드(kernal mode)에서 동작 (프로세서나 주기억 장치에 제한 없이 접근 가능_이 권한으로 전체 시스템 파괴가능...)
> > 커널 공간(kernal space): 커널만 접근할 수 있는 영역
>    
> **3.프로세스(사용자 프로세스(user process))** <br>
> > 상위레벨(사용자 공간) 구성<br>
> > 커널이 관리하는 실행중인 프로그램<br>
> > 프로세서와 직접 교류 여부와 상관 없이 모두 사용자 프로세스라 함<br>
> > <pre><code> ex)웹서버</pre></code>
> > 사용자 모드(user mode)에서 동작 (메모리 공간의 일부와 안전한 CPU작업에만 접근가능)
> > 사용자 공간 : 사용자 프로세스가 접근할 수 있는 주기억 공간 일부(문제가 발생해도 결과가 제한적이며 커널에서 해결 가능한 수준)
>   
> <img src="https://user-images.githubusercontent.com/74286330/174033762-57e89dfb-d0cf-4345-bd4f-374c1679b712.png" width="450px" height="300px" title="px(픽셀) 크기 설정" alt="img"></img><br/>
> 
<br>
<br>
<hr/>   

1.2 하드웨어: 주기억 장치에 대한<br>
> 주기억 장치(main memory) <br>
> > 0,1(0,1을 비트라 함)을 위한 커다란 저장공간<br>
> > 실행중인 커널과 프로세스가 상주하는 공간이자 커다란 비트의 집합체(주변 장치의 모든 입력과 출력이 비트묶음 형태로 주기억장치로 흘러들어감)<br>
> > CPU : 메모리상의 운영자, 명령들과 메모리의 데이터를 읽고 메모리에 다시 데이터를 기록<br>
> 상태(state) : 비트의 특정한 배열<br>
> <pre><code> ex)4비트, 0110, 0001, 1011 세가지 다른 종류의 상태를 표현</pre></code>
> 하나의 프로세스가 메모리에서 수백만의 비트로 구성 될 수 있어서 상태를 추상적 용어로 사용하는 것이 더 일반적이다.
> <pre><code> ex)프로세스가 입력을 기다리고 있다.   
> 프로세스가 스타트업(시동)의 2단계를 수행하고 있다.</pre></code>
>
<br>
<br>
<hr/>   

1.3 커널<br>
> 커널이 실행하는 거의 모든 작업은 주기억 장치를 위주로 진행됨 <br>
> 메모리를 여러개의 구획으로 분리하고 세분회된 구획에 대한 상태 정보를 항상 보유<br>
> 일반적인 시스템 영역 내의 네가지 작업들을 유지하는 책임을 맡음
> <pre><code>프로세스 : 어떤 프로세스가 CPU의 사용을 허용받았는지 알아야함
> 메모리 : 모든 메모리를 지속적으로 파악해야함 (할당된 메모리, 할당되지 않은 메모리, 프로세스간 공유할 수 있는 메모리)
> 장치 드라이버 : 하드웨어와 프로세스 사이의 인터페이스로 동작, 하드웨어를 운영하는 일을 맡음
> 시스템 콜과 지원 : 프로세스는 보통 코널과 소통하는데 시스템콜을 사용함</pre></code>
>
<br>
<br>
<hr/>   

1.3.1 프로세스 관리<br>
> 프로세스의 시작, 멈춤, 재개와 종료 <br>
> **문맥전환(context switch)** : 하나의 프로세스가 다른 프로세스를 위해 CPU에 대한 제어를 포기하는 행위<br>
> **타임슬라이스(time slice)** : 각 시간의 조각<br>
> **다중 작업 처리(multitasking)능력** : 타임슬라이스가 너무 작아 인지 할 수 없으며 시스템이 마치 동시에 다수의 프로세스를 실행하는 것 처럼 보이게됨<br>
> <br>
> **문맥전환** (한 프로세스가 사용자 모드에서 실행중이며 타임슬라이스가 종료된 상황)<br>
> > <pre><code>1. CPU(실질적 하드웨어)는 내부 타이머를 기초로 하여 현재 프로세스를 중단하고 커널 모드로 전환, 통제권을 넘김<br>
> > 2. 커널이 CPU와 메모리 상태를 기록(중단된 프로세스 재개시 필수)
> > 3. 커널이 이전 타임 슬라이스 동안 발생해야 했던 작업 실행(입력과 출력, I/O, 여러활동에서 데이터 수집하는 작업 등)<br>
> > 4. 커널은 다른 프로세스가 동작할 수 있도록 준비, 준비가 된 프로세스 목록을 분석, 하나 선택<br>
> > 5. 커널이 새 프로세스를 위한 메모리를 준비, CPU를 준비시킴<br>
> > 6. 커널이 새 프로세스를 위한 타임 슬라이스가 얼마나 걸릴지 CPU에게 알림<br>
> > 7. 커널이 사용자 모드로 CPU전환, CPU통제권을 프로세스에 넘김<br>
> > ▶커널은 문맥 전환이 이뤄지는 동안 프로세스의 타임 슬라이스 사이 사이에 실행됨 
> > </pre></code>
> > 단, 다수의 CPU를 갖춘 시스템은 약간 더 복잡함
> 
<br>
<br>
<hr/>   

1.3.2 메모리 관리<br>
> 커널은 문맥 전환이 이뤄지는 동안 메모리를 관리해야함 <br>
> 관리조건
> > <pre><code>·커널은 사용자 프로세스가 접근 할 수 없는 전용 영역을 메모리 안에 보유해야함<br>
> > ·각 사용자 프로세스는 자신만의 메모리 구역이 있어야 함<br>
> > ·하나의 사용자 프로세스는 다른 프로세스의 전용 영역에 접근할 수 없음<br>
> > ·사용자 프로세스들은 메모리를 공유할 수 있음<br>
> > ·사용자 프로세스에서 일부 메모리는 읽기 전용이 될 수 있음<br>
> > ·시스템은 보조로 디스크 공간을 사용함으로써 물리적으로 존재하는 것보다 더 많은 메모리를 사용할 수 있음<br>
> > </pre></code>
> 가상메모리(virtual memory) : CPU가 가지고 있는 메모리 관리 유닛(memory management unit,MMU), 메모리 접근을 계획할 수 있게 해줌<br>
> 가상메모리를 사용할 때 커널은 각각의 프로세스가 머신 전체를 점유하고 있는 것처럼 동작하도록 해당 프로세스를 설정, <br>
> 프로세스가 메모리의 일정 부분에 접근할 때 MMU는 그 접근을 가로채서 메모리 어드레스 맵(메모리 주소 지도)을 사용하여 프로세스의 메모리 위치를 머신상의 실절적인 물리적 메모리 위치로 변환시킴<br>
> 커널은 여전히 이 메모리어드레스맵을 초기화시키고 지속적으로 유지하며 변경해야함<br>
> > 
<br>
<br>
<hr/>   

1.3.3 장치 드라이버와 관리<br>
> 장치는 보통 커널 모드에서만 접근할 수 있음<br>
> 부적절한 접근(ex,전원공급중단)으로 머신 손상을 불러 올 수 있고 서로 다른 장비가 한 작업을 해도 대부분 다른 프로그래밍 인터페이스를 갖기 때문에 장치 드라이버는 전통적으로 커널의 영역<br>
>
<br>
<br>
<hr/>

1.3.4 시스템 호출과 지원<br>
> 파일을 열고 읽고 쓰는 기능은 시스템 콜과 관련있음<br>
> 사용자 프로세스 단독으로는 잘못하거나 할 수 없는 작업을 수행<br>
> <pre><code>fork() : 커널이 프로세스와 거의 일치하는 복사본을 만듦
> exec() : 커널이 프로그램을 시작하여 현재 프로세스를 대신함
> </pre></code>
>
<br>
<br>
<hr/>   
